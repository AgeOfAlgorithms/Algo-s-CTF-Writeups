#!/usr/bin/env python3
"""
Exploit for Ashes to Ashes challenge - Hash collision attack
Author: Claude
Purpose: Find two messages that produce the same hash using differential cryptanalysis
Description: Exploits the linearity of the ashes hash function to create a collision
"""

import requests
import json
from typing import Iterable

# Hash function from the challenge
C = bytes([0xA5]) * 16

def _to_u128(b: bytes) -> int:
    return int.from_bytes(b, "little")

def _from_u128(x: int) -> bytes:
    return x.to_bytes(16, "little")

def _rol13(x: int) -> int:
    return ((x << 13) | (x >> (128 - 13))) & ((1 << 128) - 1)

def _ror13(x: int) -> int:
    return ((x >> 13) | (x << (128 - 13))) & ((1 << 128) - 1)

def ashes_hash(msg: bytes) -> bytes:
    # process in 16-byte blocks; zero-pad last partial block
    if len(msg) % 16 != 0:
        pad_len = 16 - (len(msg) % 16)
        msg += b"\x00" * pad_len

    S = 0  # 128-bit IV = 0
    c = _to_u128(C)

    for i in range(0, len(msg), 16):
        m = _to_u128(msg[i:i+16])
        if ((i // 16) % 2) == 0:  # even
            S = _rol13(S ^ m) ^ c
        else:                      # odd
            S = _ror13(S ^ m) ^ c

    return _from_u128(S)

def create_collision(prefix: bytes) -> tuple[bytes, bytes]:
    """
    Create two messages that hash to the same value using the vulnerability described in the challenge.
    """
    # Pad prefix to 16-byte boundary
    if len(prefix) % 16 != 0:
        pad_len = 16 - (len(prefix) % 16)
        prefix += b"\x00" * pad_len

    # First custom block will be at index len(prefix) // 16
    first_custom_block_idx = len(prefix) // 16

    # Pick arbitrary 16-byte blocks A1, A2 and non-zero difference Î”
    A1 = b"CONTROLLEDBLOCK1"
    A2 = b"CONTROLLEDBLOCK2"
    DELTA = _to_u128(b"DIFFERENCEDELTA")  # Non-zero difference

    # Calculate B1 and B2 based on whether first custom block is even or odd
    B1 = _to_u128(A1) ^ DELTA

    if first_custom_block_idx % 2 == 0:  # even block - use left rotation
        B2 = _to_u128(A2) ^ _rol13(DELTA)
    else:  # odd block - use right rotation
        B2 = _to_u128(A2) ^ _ror13(DELTA)

    # Convert back to bytes
    B1_bytes = _from_u128(B1)
    B2_bytes = _from_u128(B2)

    # Create the two messages
    m1 = prefix + A1 + A2
    m2 = prefix + B1_bytes + B2_bytes

    return m1, m2

def test_exploit():
    """Test the exploit locally"""
    # Test with a simple prefix
    prefix = b"TESTPREFIX"
    m1, m2 = create_collision(prefix)

    print(f"Prefix: {prefix.hex()}")
    print(f"Message 1: {m1.hex()}")
    print(f"Message 2: {m2.hex()}")

    h1 = ashes_hash(m1)
    h2 = ashes_hash(m2)

    print(f"Hash 1: {h1.hex()}")
    print(f"Hash 2: {h2.hex()}")
    print(f"Collision successful: {h1 == h2}")

def exploit_target():
    """Exploit the actual target service"""
    target_url = "https://crypto100-4.pointeroverflowctf.com"

    try:
        # Get prefix and session ID (disable SSL verification for CTF target)
        print("Getting prefix and session ID...")
        response = requests.post(f"{target_url}/prefix", verify=False)
        print(f"Response status: {response.status_code}")
        print(f"Response text: {response.text}")

        if response.status_code != 200:
            print(f"Failed to get prefix: {response.status_code}")
            return

        try:
            data = response.json()
            prefix = data['prefix'].encode('ascii')  # It's already ASCII, not hex
            session_id = data['session_id']
        except (json.JSONDecodeError, KeyError) as e:
            print(f"Error parsing response: {e}")
            print(f"Raw response: {response.text}")
            return

        print(f"Received prefix: {prefix.hex()}")
        print(f"Session ID: {session_id}")
        print(f"Prefix length: {len(prefix)}")

        # Create collision messages
        m1, m2 = create_collision(prefix)

        print(f"Message 1 length: {len(m1)}")
        print(f"Message 2 length: {len(m2)}")

        # Verify collision locally first
        h1 = ashes_hash(m1)
        h2 = ashes_hash(m2)
        print(f"Local collision check: {h1.hex()} == {h2.hex()} -> {h1 == h2}")

        # Submit the collision
        payload = {
            "session_id": session_id,
            "m1_hex": m1.hex(),
            "m2_hex": m2.hex()
        }

        print("Submitting collision...")
        response = requests.post(
            f"{target_url}/submit",
            headers={"Content-Type": "application/json"},
            data=json.dumps(payload),
            verify=False
        )

        print(f"Response status: {response.status_code}")
        print(f"Response: {response.text}")

    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    print("Testing exploit locally...")
    test_exploit()
    print("\n" + "="*50 + "\n")
    print("Attempting to exploit target...")
    exploit_target()